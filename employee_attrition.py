# -*- coding: utf-8 -*-
"""Employee_Attrition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WDU0BtI5XXAuscxh4SN__eFHIgkY9g_b
"""

!pip install -U -q PyDrive
import os
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

"""#1. Nhập dữ liệu"""

import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
#import data
file_id = '17yfhJopcugK94AkI2BfpCTZ5pihTDtp9'
downloaded = drive.CreateFile({'id': file_id})
downloaded.GetContentFile('Employee_Attrition.csv')
df = pd.read_csv("Employee_Attrition.csv",header = 0)
drop_cols = ['EmployeeCount','Over18','StandardHours', 'EmployeeNumber']
# df = df.drop(drop_cols, axis=1)

mapping={'Yes': 1, 'No': 0}
df=df.replace({'Attrition': mapping})
Y=df.Attrition

mapping={'Sales Executive': 0,
         'Research Scientist': 1,
         'Laboratory Technician':2,
         'Manufacturing Director':3,
         'Healthcare Representative':4,
         'Manager':5,
         'Sales Representative':6,
         'Research Director':7,
         'Human Resources':8}
df=df.replace({'JobRole': mapping})
#Label Encoder
from sklearn.preprocessing import LabelEncoder
for f in df.columns:
  if df[f].dtype == "object":
    le = LabelEncoder()
    df[f] = le.fit_transform(df[f].astype(str))

"""# 2. Tính Emloyee Value"""

#MonthlyIncome
MonthlyIncome = df.groupby('JobRole')['MonthlyIncome'].rank(ascending=False)
df['new'] = MonthlyIncome
MonthlyIncome = df.groupby('JobRole')['new'].apply(lambda x: (x/x.max()))
df = df.drop('new', axis =1)
#PerformanceRating
PerformanceRating = df['PerformanceRating'].rank(ascending=False)
PerformanceRating = PerformanceRating/len(df)
#JobLevel
JobLevel = df['JobLevel'].rank(ascending=False)
JobLevel = JobLevel/len(df)
#Overal Rank
result = MonthlyIncome + PerformanceRating +  JobLevel
result = result.rank(ascending=False)
df['rank_evm'] = result/len(df)

print(df[['EmployeeNumber','rank_evm']])

"""# 3. Correlation Matrix"""

#Correlation Matrix
corrmat = df.corr()
f, ax = plt.subplots(figsize=(20, 15))
cols=df.columns.values
cm = np.corrcoef(df.values.T)
sns.set(font_scale=1.25)
hm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols, xticklabels=cols)
plt.show()

"""# Tỉ lệ Churn của bộ dữ liệu có nhãn"""

def make_autopct(values):
    def my_autopct(pct):
        total = sum(values)
        val = int(round(pct*total/100.0))
        return '{p:.2f}%  ({v:d})'.format(p=pct,v=val)
    return my_autopct

plt.figure(figsize=plt.figaspect(1))

sums = df["Attrition"].groupby(df["Attrition"]).count()
labels = ['No','Yes']
# plt.pie(sums, labels=sums.index);

plt.pie(sums, labels=labels,
        autopct=make_autopct(sums), shadow=True, startangle=140)
plt.axis('equal')
plt.title('Attrition Status')

plt.show()

"""# Thống kê tổng quan: Những khách hàng rời bỏ, những khách hàng ở lại"""

# Thống kê tổng quan: Những người bỏ việc có job level thấp hơn so với những người không bỏ việc; Mức lương của những người bỏ việc thấp hơn 30% so với người không bỏ việc; độ tuổi trung bình người bỏ việc là 33; người không bỏ việc là 37. 
Attrition_Summary = df.groupby('Attrition')
Attrition_Summary.mean()
#print(Attrition_Summary.mean().JobLevel,Attrition_Summary.mean().MonthlyIncome,Attrition_Summary.mean().PerformanceRating, Attrition_Summary.mean().Age)

"""# Phân tích dữ liệu

**1. Visualize Data**
"""

# print("Employee Distribution")
A = df.drop('Attrition', axis =1)
NoAttritionFrame = df.loc[(df.Attrition == 0)]
AttritionFrame=df.loc[(df.Attrition==1)]

for column in A:
  f, axes = plt.subplots(ncols=3, figsize=(15, 6))
  # Employee Distribution
  sns.distplot(A[column], kde=False, color="g", ax=axes[0]).set_title('Employee ' + column + ' Distribution')
  # Attrition Employee Distribution
  sns.distplot(AttritionFrame[column], kde=False, color="r", ax=axes[1]).set_title('Attrition Employee ' + column + ' Distribution')
  # NoAttrition Employee Distribution
  sns.distplot(NoAttritionFrame[column], kde=False, color="b", ax=axes[2]).set_title('NoAttrition Employee ' + column + ' Distribution')

#Percent Attrition Employee
for column in A:
  x = []
  y = []
  unique = df[column].unique()
  for value in unique:
    x.append(value)
    y.append(len(df.loc[(df.Attrition == 1) & (df[column] == value)])/len(df.loc[(df[column] == value)])*100)
  plt.bar(x, y, color="blue")
  plt.xlabel(column)
  plt.ylabel('%')
  plt.title('Percent Attrition Employee ' + column + ' Distribution ')
  plt.show()

# sns.barplot(x="JobSatisfaction", y="EducationField", data=df)
# sns.set()
# plt.title('Educational Field against Job Satisfaction')

# sns.boxplot(x="OverTime", y="RelationshipSatisfaction", hue="Gender", data=df)
# sns.set()
# plt.title('Overtime against Relationship satisfaction')

# sns.boxplot(x="Gender", y="JobSatisfaction", data=df)
# sns.set()
# plt.title('Job satisfaction against Gender')

# sns.boxplot(x="EducationField", y="MonthlyIncome", data=df, hue="Gender")
# sns.set()
# plt.title('Monthly income against Educational Field')

# sns.boxplot(x="WorkLifeBalance", y="DistanceFromHome", data=df)
# sns.set()
# plt.title('Distance from home against Work life balance')

"""**2. Phân tích các trường thuộc tính quan trọng**

# Kết quả dự báo: Mô tả qua đường cong ROC
"""

features = [f for f in df if f not in 'Attrition' ]
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn import model_selection, svm
from sklearn.metrics import roc_curve, auc
X=df[features]
Y=df['Attrition']
model_rfc = RandomForestClassifier()
#model_knc = KNeighborsClassifier() 
model_lr = LogisticRegression() 
#model_gb = GradientBoostingClassifier()
model_svc = svm.SVC()

roc_train_all, roc_test_all, roc_train_all_class, roc_test_all_class = model_selection.train_test_split(X, Y, test_size=0.2) 
roc_train_best, roc_test_best, roc_train_best_class, roc_test_best_class = model_selection.train_test_split(X, Y, test_size=0.2) 

models = [
    
#     {
#         'label' : 'GradientBoosting',
#         'model': model_gb,
#         'roc_train': roc_train_best,
#         'roc_test': roc_test_best,
#         'roc_train_class': roc_train_best_class,        
#         'roc_test_class': roc_test_best_class,                
#     },
    {
        'label' : 'RandomForestClassifier',
        'model': model_rfc,
        'roc_train': roc_train_best,
        'roc_test': roc_test_best,
        'roc_train_class': roc_train_best_class,        
        'roc_test_class': roc_test_best_class,        
    }, 
    {
        'label' : 'Support Vector Machine',
        'model': model_svc,
        'roc_train': roc_train_best,
        'roc_test': roc_test_best,
        'roc_train_class': roc_train_best_class,        
        'roc_test_class': roc_test_best_class,        
    },
    
#     {
#         'label' : 'KNeighborsClassifier',
#         'model': model_knc,
#         'roc_train': roc_train_all,
#         'roc_test': roc_test_all,
#         'roc_train_class': roc_train_all_class,        
#         'roc_test_class': roc_test_all_class,        
#     },
    {
        'label' : 'LogisticRegression',
        'model': model_lr,
        'roc_train': roc_train_all,
        'roc_test': roc_test_all,
        'roc_train_class': roc_train_all_class,        
        'roc_test_class': roc_test_all_class,        
    }        
]


plt.clf()
fig = plt.figure(figsize=(8,6))

for m in models:
    m['model'].probability = True
    probas = m['model'].fit(m['roc_train'], m['roc_train_class']).predict_proba(m['roc_test'])
    fpr, tpr, thresholds = roc_curve(m['roc_test_class'], probas[:, 1])
    roc_auc  = auc(fpr, tpr)
    plt.plot(fpr, tpr, label='%s ROC (area = %0.2f)' % (m['label'], roc_auc))


plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.0])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend(loc=0, fontsize='small')
plt.show()
#fig.savefig("0_CMC-FintechChurnPrediction/EmployeeChurn+CLVChurn/Code/roc.pdf")

